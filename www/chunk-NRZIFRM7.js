import{n as y,na as N}from"./chunk-MUBZYPCN.js";import{a as b,b as E,d as T}from"./chunk-HKEYXBPG.js";import{f as m,h as s}from"./chunk-ECACSZ36.js";var d,h,p=m(()=>{"use strict";d=class{constructor(e){this.sqlite=e,this._connectionDict=new Map}initWebStore(){return s(this,null,function*(){try{return yield this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}})}saveToStore(e){return s(this,null,function*(){try{return yield this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}})}saveToLocalDisk(e){return s(this,null,function*(){try{return yield this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}})}getFromLocalDiskToStore(e){return s(this,null,function*(){let t=e??!0;try{return yield this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}})}echo(e){return s(this,null,function*(){try{let t=yield this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}isSecretStored(){return s(this,null,function*(){try{let e=yield this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}setEncryptionSecret(e){return s(this,null,function*(){try{return yield this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}})}changeEncryptionSecret(e,t){return s(this,null,function*(){try{return yield this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(r){return Promise.reject(r)}})}clearEncryptionSecret(){return s(this,null,function*(){try{return yield this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}})}checkEncryptionSecret(e){return s(this,null,function*(){try{let t=yield this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}addUpgradeStatement(e,t){return s(this,null,function*(){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),yield this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(r){return Promise.reject(r)}})}createConnection(e,t,r,a,o){return s(this,null,function*(){try{e.endsWith(".db")&&(e=e.slice(0,-3)),yield this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:a,readonly:o});let i=new h(e,o,this.sqlite),n=o?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(n,i),Promise.resolve(i)}catch(i){return Promise.reject(i)}})}closeConnection(e,t){return s(this,null,function*(){try{e.endsWith(".db")&&(e=e.slice(0,-3)),yield this.sqlite.closeConnection({database:e,readonly:t});let r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(r){return Promise.reject(r)}})}isConnection(e,t){return s(this,null,function*(){let r={};e.endsWith(".db")&&(e=e.slice(0,-3));let a=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(a),Promise.resolve(r)})}retrieveConnection(e,t){return s(this,null,function*(){e.endsWith(".db")&&(e=e.slice(0,-3));let r=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(r)){let a=this._connectionDict.get(r);return typeof a<"u"?Promise.resolve(a):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)})}getNCDatabasePath(e,t){return s(this,null,function*(){try{let r=yield this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}})}createNCConnection(e,t){return s(this,null,function*(){try{yield this.sqlite.createNCConnection({databasePath:e,version:t});let r=new h(e,!0,this.sqlite),a=`RO_${e})`;return this._connectionDict.set(a,r),Promise.resolve(r)}catch(r){return Promise.reject(r)}})}closeNCConnection(e){return s(this,null,function*(){try{yield this.sqlite.closeNCConnection({databasePath:e});let t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}})}isNCConnection(e){return s(this,null,function*(){let t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)})}retrieveNCConnection(e){return s(this,null,function*(){if(this._connectionDict.has(e)){let t=`RO_${e})`,r=this._connectionDict.get(t);return typeof r<"u"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)})}isNCDatabase(e){return s(this,null,function*(){try{let t=yield this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}retrieveAllConnections(){return s(this,null,function*(){return this._connectionDict})}closeAllConnections(){return s(this,null,function*(){let e=new Map;try{for(let t of this._connectionDict.keys()){let r=t.substring(3),a=t.substring(0,3)==="RO_";yield this.sqlite.closeConnection({database:r,readonly:a}),e.set(t,null)}for(let t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}})}checkConnectionsConsistency(){return s(this,null,function*(){try{let e=[...this._connectionDict.keys()],t=[],r=[];for(let o of e)t.push(o.substring(0,2)),r.push(o.substring(3));let a=yield this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return a.result||(this._connectionDict=new Map),Promise.resolve(a)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}})}importFromJson(e){return s(this,null,function*(){try{let t=yield this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}isJsonValid(e){return s(this,null,function*(){try{let t=yield this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}copyFromAssets(e){return s(this,null,function*(){let t=e??!0;try{return yield this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}})}getFromHTTPRequest(e,t){return s(this,null,function*(){let r=t??!0;try{return yield this.sqlite.getFromHTTPRequest({url:e,overwrite:r}),Promise.resolve()}catch(a){return Promise.reject(a)}})}isDatabaseEncrypted(e){return s(this,null,function*(){e.endsWith(".db")&&(e=e.slice(0,-3));try{let t=yield this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}isInConfigEncryption(){return s(this,null,function*(){try{let e=yield this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}isInConfigBiometricAuth(){return s(this,null,function*(){try{let e=yield this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}isDatabase(e){return s(this,null,function*(){e.endsWith(".db")&&(e=e.slice(0,-3));try{let t=yield this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}getDatabaseList(){return s(this,null,function*(){try{let t=(yield this.sqlite.getDatabaseList()).values;t.sort();let r={values:t};return Promise.resolve(r)}catch(e){return Promise.reject(e)}})}getMigratableDbList(e){return s(this,null,function*(){let t=e||"default";try{let r=yield this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}})}addSQLiteSuffix(e,t){return s(this,null,function*(){let r=e||"default",a=t||[];try{let o=yield this.sqlite.addSQLiteSuffix({folderPath:r,dbNameList:a});return Promise.resolve(o)}catch(o){return Promise.reject(o)}})}deleteOldDatabases(e,t){return s(this,null,function*(){let r=e||"default",a=t||[];try{let o=yield this.sqlite.deleteOldDatabases({folderPath:r,dbNameList:a});return Promise.resolve(o)}catch(o){return Promise.reject(o)}})}moveDatabasesAndAddSuffix(e,t){return s(this,null,function*(){let r=e||"default",a=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:r,dbNameList:a})})}},h=class{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}open(){return s(this,null,function*(){try{return yield this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}})}close(){return s(this,null,function*(){try{return yield this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}})}beginTransaction(){return s(this,null,function*(){try{let e=yield this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}commitTransaction(){return s(this,null,function*(){try{let e=yield this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}rollbackTransaction(){return s(this,null,function*(){try{let e=yield this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}isTransactionActive(){return s(this,null,function*(){try{let e=yield this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}loadExtension(e){return s(this,null,function*(){try{return yield this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}})}enableLoadExtension(e){return s(this,null,function*(){try{return yield this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}})}getUrl(){return s(this,null,function*(){try{let e=yield this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}getVersion(){return s(this,null,function*(){try{let e=yield this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}getTableList(){return s(this,null,function*(){try{let e=yield this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}execute(e,t=!0,r=!0){return s(this,null,function*(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{let a=yield this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(a)}}catch(a){return Promise.reject(a)}})}query(e,t,r=!0){return s(this,null,function*(){let a;try{return t&&t.length>0?a=yield this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):a=yield this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),a=yield this.reorderRows(a),Promise.resolve(a)}catch(o){return Promise.reject(o)}})}run(e,t,r=!0,a="no",o=!0){return s(this,null,function*(){let i;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?i=yield this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:a,isSQL92:!0}):i=yield this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:a,isSQL92:o}),i.changes=yield this.reorderRows(i.changes),Promise.resolve(i))}catch(n){return Promise.reject(n)}})}executeSet(e,t=!0,r="no",a=!0){return s(this,null,function*(){let o;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(o=yield this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:a}),o.changes=yield this.reorderRows(o.changes),Promise.resolve(o))}catch(i){return Promise.reject(i)}})}isExists(){return s(this,null,function*(){try{let e=yield this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}isTable(e){return s(this,null,function*(){try{let t=yield this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}})}isDBOpen(){return s(this,null,function*(){try{let e=yield this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}})}delete(){return s(this,null,function*(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(yield this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}})}createSyncTable(){return s(this,null,function*(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{let e=yield this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}})}setSyncDate(e){return s(this,null,function*(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(yield this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}})}getSyncDate(){return s(this,null,function*(){try{let e=yield this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly}),t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}})}exportToJson(e,t=!1){return s(this,null,function*(){try{let r=yield this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}})}deleteExportedRows(){return s(this,null,function*(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(yield this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}})}executeTransaction(e,t=!0){return s(this,null,function*(){let r=0,a=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(yield this.sqlite.beginTransaction({database:this.dbName}),a=yield this.sqlite.isTransactionActive({database:this.dbName}),!a)return Promise.reject("After Begin Transaction, no transaction active");try{for(let n of e){if(typeof n!="object"||!("statement"in n))throw new Error("Error a task.statement must be provided");if("values"in n&&n.values&&n.values.length>0){let c=n.statement.toUpperCase().includes("RETURNING")?"all":"no",u=yield this.sqlite.run({database:this.dbName,statement:n.statement,values:n.values,transaction:!1,readonly:!1,returnMode:c,isSQL92:t});if(u.changes.changes<0)throw new Error("Error in transaction method run ");r+=u.changes.changes}else{let c=yield this.sqlite.execute({database:this.dbName,statements:n.statement,transaction:!1,readonly:!1});if(c.changes.changes<0)throw new Error("Error in transaction method execute ");r+=c.changes.changes}}let o=yield this.sqlite.commitTransaction({database:this.dbName});r+=o.changes.changes;let i={changes:{changes:r}};return Promise.resolve(i)}catch(o){let i=o.message?o.message:o;return yield this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(i)}})}reorderRows(e){return s(this,null,function*(){let t=e;if(e?.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){let r=e.values[0].ios_columns,a=[];for(let o=1;o<e.values.length;o++){let i=e.values[o],n={};for(let c of r)n[c]=i[c];a.push(n)}t.values=a}return Promise.resolve(t)})}}});var S,g=m(()=>{"use strict";T();p();S=E("CapacitorSQLite",{web:()=>import("./chunk-XE6HRTAC.js").then(l=>new l.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite})});var C,f=m(()=>{"use strict";g();T();N();C=(()=>{let e=class e{constructor(){this.isInitialized=!1,this.platform=b.getPlatform(),this.sqlite=new d(S)}initialize(){return s(this,null,function*(){if(this.isInitialized){console.log("[DatabaseService] Already initialized");return}try{if(console.log("[DatabaseService] Starting initialization on platform:",this.platform),this.platform==="web"){console.log("[DatabaseService] \u{1F50D} Checking WebStore status..."),console.log("[DatabaseService] Current isSQLiteInitialized:",window.isSQLiteInitialized);let c=0,u=50;for(;!window.isSQLiteInitialized&&c<u;)console.log(`[DatabaseService] \u23F3 Waiting for WebStore... (attempt ${c+1}/${u})`),yield new Promise(w=>setTimeout(w,100)),c++;if(!window.isSQLiteInitialized)throw console.error("[DatabaseService] \u274C WebStore initialization timeout after",c*100,"ms"),new Error("WebStore initialization timeout");console.log("[DatabaseService] \u2705 WebStore is ready after",c*100,"ms")}let r="meuapp_db",a=!1,o="no-encryption",i=1,n=!1;this.db=yield this.sqlite.createConnection(r,a,o,i,n),console.log("[DatabaseService] Connection created"),yield this.db.open(),console.log("[DatabaseService] Database opened"),yield this.createTables(),console.log("[DatabaseService] Tables created"),this.platform==="web"&&(yield this.checkAndRestoreBackup()),this.isInitialized=!0,console.log(`[DatabaseService] \u2705 Database initialized successfully on ${this.platform}`)}catch(r){throw console.error("[DatabaseService] \u274C Error initializing database:",r),r}})}createTables(){return s(this,null,function*(){yield this.db.execute(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        nome TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        avatar_url TEXT,
        telefone TEXT,
        data_nascimento TEXT,
        bio TEXT,
        roles TEXT NOT NULL,
        data_criacao TEXT NOT NULL,
        ultima_atualizacao TEXT NOT NULL,
        ativo INTEGER DEFAULT 1
      );
      -- ... O resto das tuas CREATE TABLE e INDEX ...
      CREATE TABLE IF NOT EXISTS user_preferences (
        user_id TEXT PRIMARY KEY,
        tema TEXT DEFAULT 'auto',
        idioma TEXT DEFAULT 'pt-BR',
        notificacoes_push INTEGER DEFAULT 1,
        notificacoes_email INTEGER DEFAULT 1,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS categories (
        id TEXT PRIMARY KEY,
        nome TEXT NOT NULL,
        cor TEXT NOT NULL,
        icone TEXT,
        user_id TEXT NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS projects (
        id TEXT PRIMARY KEY,
        nome TEXT NOT NULL,
        descricao TEXT,
        cor TEXT NOT NULL,
        is_public INTEGER DEFAULT 0,
        criado_por TEXT NOT NULL,
        status TEXT NOT NULL,
        data_criacao TEXT NOT NULL,
        data_atualizacao TEXT NOT NULL,
        FOREIGN KEY (criado_por) REFERENCES users(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS project_members (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        user_id TEXT NOT NULL,
        role TEXT NOT NULL,
        adicionado_em TEXT NOT NULL,
        FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        UNIQUE(project_id, user_id)
      );

      CREATE TABLE IF NOT EXISTS tasks (
        id TEXT PRIMARY KEY,
        titulo TEXT NOT NULL,
        descricao TEXT,
        status TEXT NOT NULL,
        prioridade TEXT NOT NULL,
        data_criacao TEXT NOT NULL,
        data_atualizacao TEXT NOT NULL,
        data_vencimento TEXT,
        data_conclusao TEXT,
        user_id TEXT NOT NULL,
        project_id TEXT,
        category_id TEXT,
        tags TEXT DEFAULT '[]',
        anexos TEXT DEFAULT '[]',
        is_public INTEGER DEFAULT 0,
        assigned_to TEXT DEFAULT '[]',
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE SET NULL,
        FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
      );

      CREATE TABLE IF NOT EXISTS auth_tokens (
        user_id TEXT PRIMARY KEY,
        token TEXT NOT NULL,
        refresh_token TEXT NOT NULL,
        expires_at TEXT NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_project_id ON tasks(project_id);
      CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
      CREATE INDEX IF NOT EXISTS idx_projects_user_id ON projects(criado_por);
      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    `),yield this.saveToStore()})}getDb(){return s(this,null,function*(){return this.isInitialized||(yield this.initialize()),this.db})}query(o){return s(this,arguments,function*(r,a=[]){return yield(yield this.getDb()).query(r,a)})}run(o){return s(this,arguments,function*(r,a=[]){let n=yield(yield this.getDb()).run(r,a);return yield this.saveToStore(),n})}saveToStore(){return s(this,null,function*(){try{console.log(`[DatabaseService] \u{1F4BE} Saving database to store (platform: ${this.platform})...`),yield this.sqlite.saveToStore("meuapp_db"),console.log("[DatabaseService] \u2705 Database saved to IndexedDB/store successfully"),this.platform==="web"&&(console.log("[DatabaseService] \u{1F4BE} Creating localStorage backup..."),yield this.backupToLocalStorage(),console.log("[DatabaseService] \u2705 localStorage backup created"))}catch(r){throw console.error("[DatabaseService] \u274C Error saving to store:",r),r}})}backupToLocalStorage(){return s(this,null,function*(){try{let r=yield this.exportDatabaseToJson();localStorage.setItem("meuapp_db_backup",r),localStorage.setItem("meuapp_db_backup_timestamp",new Date().toISOString()),console.log("[DatabaseService] \u2705 Backup saved to localStorage")}catch(r){console.error("[DatabaseService] Error backing up to localStorage:",r)}})}forceSave(){return s(this,null,function*(){yield this.saveToStore()})}executeBatch(r){return s(this,null,function*(){yield(yield this.getDb()).execute(r.join("; ")),yield this.saveToStore()})}close(){return s(this,null,function*(){this.db&&(yield this.db.close(),this.isInitialized=!1)})}debugDatabase(){return s(this,null,function*(){this.isInitialized||(yield this.initialize()),console.log("========== DATABASE DEBUG =========="),console.log("Platform:",this.platform);let r=yield this.query("SELECT name FROM sqlite_master WHERE type='table'");console.log("Tables:",r.values);for(let a of r.values||[]){let o=a.name;console.log(`
----- Table: ${o} -----`);let i=yield this.query(`PRAGMA table_info(${o})`);console.log("Structure:",i.values);let n=yield this.query(`SELECT * FROM ${o} LIMIT 5`);console.log("First 5 rows:",n.values)}console.log("====================================")})}generateId(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,r=>{let a=Math.random()*16|0;return(r==="x"?a:a&3|8).toString(16)})}dateToSQL(r){return r.toISOString()}sqlToDate(r){return new Date(r)}exportDatabaseToJson(){return s(this,null,function*(){let a=yield(yield this.getDb()).exportToJson("full");return JSON.stringify(a,null,2)})}downloadDatabaseAsJson(){return s(this,null,function*(){let r=yield this.exportDatabaseToJson(),a=new Blob([r],{type:"application/json"}),o=URL.createObjectURL(a),i=document.createElement("a");i.href=o,i.download=`meuapp_db_export_${new Date().toISOString().split("T")[0]}.json`,i.click(),URL.revokeObjectURL(o)})}checkDatabaseExists(){return s(this,null,function*(){if(this.platform==="web")return!0;try{return(yield this.sqlite.getDatabaseList()).values?.includes("meuapp_db")||!1}catch{return!1}})}getDatabasePath(){return s(this,null,function*(){switch(this.platform){case"android":return"/data/data/io.ionic.starter/databases/meuapp_db.db";case"ios":return"Library/CapacitorDatabase/meuapp_db.db";case"web":return"IndexedDB: jeepSqlite";default:return"Unknown platform"}})}downloadDatabaseAsSQLite(){return s(this,null,function*(){if(this.platform!=="web"){console.warn("[DatabaseService] SQLite file download only available on web platform");return}try{let a=yield(yield this.getDb()).exportToJson("full"),o=JSON.stringify(a),i=new Blob([o],{type:"application/x-sqlite3"}),n=URL.createObjectURL(i),c=document.createElement("a");c.href=n,c.download=`meuapp_db_${new Date().toISOString().split("T")[0]}.sqlite`,c.click(),URL.revokeObjectURL(n),console.log("[DatabaseService] \u2705 SQLite file downloaded successfully")}catch(r){throw console.error("[DatabaseService] Error downloading SQLite file:",r),r}})}restoreFromLocalStorage(){return s(this,null,function*(){try{let r=localStorage.getItem("meuapp_db_backup"),a=localStorage.getItem("meuapp_db_backup_timestamp");if(!r)return console.log("[DatabaseService] No backup found in localStorage"),!1;console.log(`[DatabaseService] Restoring backup from ${a}`);let o=JSON.parse(r);this.isInitialized&&(yield this.db.close(),this.isInitialized=!1);let i=JSON.stringify(o);return yield this.sqlite.importFromJson(i),yield this.initialize(),console.log("[DatabaseService] \u2705 Database restored from localStorage backup"),!0}catch(r){return console.error("[DatabaseService] Error restoring from localStorage:",r),!1}})}checkBackupInfo(){return s(this,null,function*(){let r=localStorage.getItem("meuapp_db_backup"),a=localStorage.getItem("meuapp_db_backup_timestamp");if(r){let i=(r.length/1024).toFixed(2);console.log("[DatabaseService] Backup available:"),console.log(`  - Size: ${i} KB`),console.log(`  - Timestamp: ${a}`),console.log("  - To restore: await window.db.restoreFromLocalStorage()")}else console.log("[DatabaseService] No backup found in localStorage");let o=yield this.getDatabasePath();console.log(`[DatabaseService] Current database: ${o}`)})}clearLocalStorageBackup(){localStorage.removeItem("meuapp_db_backup"),localStorage.removeItem("meuapp_db_backup_timestamp"),console.log("[DatabaseService] \u2705 localStorage backup cleared")}checkAndRestoreBackup(){return s(this,null,function*(){try{let a=(yield this.db.query("SELECT COUNT(*) as count FROM users")).values?.[0]?.count||0;console.log(`[DatabaseService] Users in database: ${a}`),a===0?localStorage.getItem("meuapp_db_backup")?(console.log("[DatabaseService] \u{1F504} Database is empty but backup exists, attempting restore..."),(yield this.restoreFromLocalStorage())&&console.log("[DatabaseService] \u2705 Database restored from backup successfully")):console.log("[DatabaseService] No backup found, starting with empty database"):console.log("[DatabaseService] Database has existing data, no restore needed")}catch(r){console.error("[DatabaseService] Error checking/restoring backup:",r)}})}};e.\u0275fac=function(a){return new(a||e)},e.\u0275prov=y({token:e,factory:e.\u0275fac,providedIn:"root"});let l=e;return l})()});export{C as a,f as b};
